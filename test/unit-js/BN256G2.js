const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("BN256G2 Tests", function () {

    // NOTE: Hardcoded msg/DST that must match with the DST specified in C++
    // unit-test, see: eth-sn-contracts/test/cpp/test/src/hash.cpp
    let DOMAIN_SEPARATION_TAG = "0xff54977c9d08fb9098f6beae0e4634cb9b2d4c2b9c86f0b3e2f2f0073b73f51c";
    let MESSAGE               = "asdf";
    let contract;

    beforeEach(async function () {
        const factory = await ethers.getContractFactory("BN256G2");
        contract      = await factory.deploy();
    });

    describe("RFC9380 hashToField", function () {
      it("Produces different values w/ different message and same DST", async function () {
        const message1 = ethers.toUtf8Bytes("message 1");
        const message2 = ethers.toUtf8Bytes("message 2");

        const result1 = await contract.hashToField(message1, DOMAIN_SEPARATION_TAG);
        const result2 = await contract.hashToField(message2, DOMAIN_SEPARATION_TAG);

        expect(result1[0]).to.not.equal(result2[0]);
        expect(result1[1]).to.not.equal(result2[1]);
      });

      it("Returns the correct 2 values and a boolean `b`", async function () {
        const hexMsg = ethers.hexlify(ethers.toUtf8Bytes(MESSAGE));
        const result = await contract.hashToField(hexMsg, DOMAIN_SEPARATION_TAG);

        // NOTE: Values calculated via JS unit-test and set in: eth-sn-contracts/test/cpp/test/src/hash.cpp
        expect(result).to.have.length(3);
        expect(result[0]).to.equal("307410635215970536626579586125711284326114787973043528925905382633054236085");
        expect(result[1]).to.equal("1183035087006320090803410940370628752170722813268233981705860145243604330069");
        expect(result[2]).to.equal(false);
      });
    });

    describe("RFC9380 expand_message_xmd", function () {
      it("Test expand via keccak256", async function () {
        const hexMsg = ethers.hexlify(ethers.toUtf8Bytes(MESSAGE));
        await expect(contract.expandMessageXMDKeccak256(hexMsg, DOMAIN_SEPARATION_TAG)).to.not.be.reverted;

        const hexStrings = await contract.expandMessageXMDKeccak256(hexMsg, DOMAIN_SEPARATION_TAG);
        expect(hexStrings).to.have.length(4);

        // NOTE: Values calculated via JS unit-test and set in: eth-sn-contracts/test/cpp/test/src/hash.cpp
        expect(hexStrings[0]).to.equal("0xa9289d6c3626c2275c7f94a2aec2b47e90522afcfacea9d7d2d6d758bfcd0209");
        expect(hexStrings[1]).to.equal("0xe929d19bf0b1b42ec2674bc2d6395aa7a1d5988766413feb1aa4dc9c2e87a15d");
        expect(hexStrings[2]).to.equal("0xd34bd9627c1e82adcdb3359afde8ddc5946db33c4255c47497956d677155af6b");
        expect(hexStrings[3]).to.equal("0x47debeec9747b0b08909e419594a087497df70f8b60fdc66ebb577dab9a33696");
      });
    });

    describe("FQ2Sqrt", function () {
      it("Zellic Test Vector", async function () {
        // NOTE: These test vectors were generated by Zellic using Sagemath from the following snippet
        // where
        //
        //  `p` is FIELD_MODULUS
        //
        // ```
        // p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
        // F = GF(p)
        //
        // R.<x> = PolynomialRing(F)
        // F2 = F.extension(x^2+1, 'i')
        //
        // real_part      = F(18400763209162137698378342072679747343805045379991482883044659141807904813804)
        // imaginary_part = F(3757716903061301937348252070019908304499894848840852657694527662312163652493)
        //
        // a = F(real_part) + F(imaginary_part) * F2.gen()
        //
        // print(a)
        // print(a.sqrt(all=True))
        // ```
        //
        // Running this produces the following data used in our test.
        //
        // ```
        // 3757716903061301937348252070019908304499894848840852657694527662312163652493*i + 18400763209162137698378342072679747343805045379991482883044659141807904813804
        // [4757623815106826332652416853619432081835467211624617316558602106633360047377*i + 21113773905939110219807704586191458336348141462234245963448200970029289972960,
        //  17130619056732448889593988891637843006860843945673206346130435788011866161206*i + 774468965900165002438701159065816752348169695063577699240836924615936235623]
        // ```
        //
        // Additional test vectors could be generated by replacing `a = F(...)` with
        // `a = F2.random_element()`

        const x1       = BigInt("18400763209162137698378342072679747343805045379991482883044659141807904813804");
        const x2       = BigInt("3757716903061301937348252070019908304499894848840852657694527662312163652493");
        const [y1, y2] = await contract.FQ2Sqrt(x1, x2);
        expect(y1).to.equal(BigInt("21113773905939110219807704586191458336348141462234245963448200970029289972960")); // Real
        expect(y2).to.equal(BigInt("4757623815106826332652416853619432081835467211624617316558602106633360047377"));  // Imaginary

        const [neg_y1, neg_y2] = await contract.NegateFQ2Sqrt(y1, y2);
        expect(neg_y1).to.equal(BigInt("774468965900165002438701159065816752348169695063577699240836924615936235623"));   // Real
        expect(neg_y2).to.equal(BigInt("17130619056732448889593988891637843006860843945673206346130435788011866161206")); // Imaginary
      });

      // NOTE: Test vectors generated via sagemath as described in 'Zellic Test Vector'
      it("Test Vector 0", async function () {
        const x1       = BigInt("18643117260133094081555630496908182148979888402907667429281989499686433042481");
        const x2       = BigInt("18767426827650792022715527615257676532671283520119768371866051896505585913537");
        const [y1, y2] = await contract.FQ2Sqrt(x1, x2);
        expect(y1).to.equal(BigInt("13983740723413048141287686746094829568564621238524191737326450062318360253841")); // Real
        expect(y2).to.equal(BigInt("7253166406823230892838512371946295413549476296573503802098707278836650652634"));  // Imaginary

        const [neg_y1, neg_y2] = await contract.NegateFQ2Sqrt(y1, y2);
        expect(neg_y1).to.equal(BigInt("7904502148426227080958718999162445520131689918773631925362587832326865954742"));  // Real
        expect(neg_y2).to.equal(BigInt("14635076465016044329407893373310979675146834860724319860590330615808575555949")); // Imaginary
      })

      it("Test Vector 1", async function () {
        const x1       = BigInt("8003427931889017305260233532064766566259865014312993643669489451621672874553");
        const x2       = BigInt("8255214349881287197796283279515869829321316620831837079694717882055223224849");
        const [y1, y2] = await contract.FQ2Sqrt(x1, x2);
        expect(y1).to.equal(BigInt("16601660172989674590467103759517356028828864343517310912312924127793849257441")); // Real
        expect(y2).to.equal(BigInt("7249251494535356504402176277173612222981755570353172297173865703654518619480"));  // Imaginary

        const [neg_y1, neg_y2] = await contract.NegateFQ2Sqrt(y1, y2);
        expect(neg_y1).to.equal(BigInt("5286582698849600631779301985739919059867446813780512750376113766851376951142"));  // Real
        expect(neg_y2).to.equal(BigInt("14638991377303918717844229468083662865714555586944651365515172190990707589103")); // Imaginary
      })
    });

});
