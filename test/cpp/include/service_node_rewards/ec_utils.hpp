#pragma once

#define BLS_ETH
#define MCLBN_FP_UNIT_SIZE 4
#define MCLBN_FR_UNIT_SIZE 4

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wold-style-cast"
#pragma GCC diagnostic ignored "-Wshadow"
#pragma GCC diagnostic ignored "-Wconversion"
#pragma GCC diagnostic ignored "-Wsign-conversion"
#include <bls/bls.hpp>
#include <mcl/bn.hpp>
#undef MCLBN_NO_AUTOLINK
#pragma GCC diagnostic pop

#include <span>

namespace utils
{
    std::string                   BLSPublicKeyToHex(const bls::PublicKey& publicKey);
    bls::PublicKey                HexToBLSPublicKey(std::string_view hex);
    std::string                   SignatureToHex(bls::Signature sig);
    std::array<unsigned char, 32> HashModulus(std::string message);

    /// Expand an arbitrary `msg` string into `out` bytes of entropy via the
    /// method outlined in RFC9380 `expand_message_xmd` detailed here:
    ///
    ///   https://www.rfc-editor.org/rfc/rfc9380.html#name-expand_message_xmd
    ///
    /// This implementation uses keccak256 as a seeding function to generate the
    /// entropy.
    ///
    /// An optional domain separation tag `dst` can be passed in as further
    /// seeding information to disambiguate the generated bytes from different
    /// domains given the same `msg`.
    ///
    /// The buffer passed in as `out` must have a capacity that is
    /// a multiple of 32 and have a capacity, 0 <= `outSize` <= 256, otherwise
    /// the function asserts. `dst` must be <= 255 bytes otherwise the
    /// function asserts.
    ///
    /// This function was taken from herumi/bls's implementation and modified to
    /// use keccak256 to align with our Solidity implementation of expand
    /// message.
    void ExpandMessageXMDKeccak256(std::span<uint8_t> out, std::span<const uint8_t> msg, std::span<const uint8_t> dst);
}
